# Data model

This document describes the current metadata schema stored in Turso.

This is the source of truth for database/data-model format rules and schema conventions.

## Principles

- Use direct SQL (no ORM).
- Prefer explicit values from application code instead of database column defaults.
- Keep `migrations/schema.sql` generated by migration tooling; do not edit it manually.
- Validate data-model primitives in app code with `arktype` and branded types.

## App-level validation conventions

- Use `arktype` as the runtime validation library for data-model primitives.
- Define branded types for constrained identifiers and fields (for example `imageSlug` and `imageExt`).
- Encode regex constraints in ArkType definitions, then validate at boundaries (request parsing, DB writes, and key composition).
- Prefer entity-specific name types over generic name validators (for example `ImageName`, `TagName`, and `TagKindName`).
- For `createServerFn` inputs, validate in `.inputValidator(...)` and normalize polymorphic inputs to discriminated unions before handler logic.
- When coercing URL strings at the boundary, parse them in ArkType morphs (`.pipe.try(...)`) instead of ad-hoc handler parsing.

## Database change rules

- Assume migrations have already been run unless explicitly told they are in progress.
- Do not edit existing migrations retroactively; create new migrations for changes.
- Do not add database column defaults in general; prefer explicit values from application code unless a default is explicitly required by the database engine/mechanism used for the migration step.

## SQL write conventions

- For idempotent create-or-update writes on SQLite/libSQL, prefer SQL UPSERT (`INSERT ... ON CONFLICT DO UPDATE`) over fetch-then-insert/update.
- Use fetch-then-branch writes only when business logic requires multi-step validation and distinct domain errors before writing.

Example:

```sql
INSERT INTO tag_kinds (slug, name, system_only)
VALUES (?, ?, 0)
ON CONFLICT(slug) DO UPDATE
SET name = excluded.name;
```

## Core tables

### images

- `slug` (`TEXT`, primary key): app-level slug without file extension.
- `ext` (`TEXT`, not null): image extension without the leading dot.
- `name` (`TEXT`, not null): user-facing display name.
- `added_at` (`INTEGER`, not null): Unix timestamp (seconds).
- `size_bytes` (`INTEGER`, not null): original image size in bytes.
- `width_px` (`INTEGER`, not null): image width in pixels.
- `height_px` (`INTEGER`, not null): image height in pixels.
- `sha256` (`TEXT`, not null): base64-encoded SHA-256 digest (not hex).
- `ready` (`INTEGER`, not null): upload lifecycle flag (`0` = not finalized, `1` = uploaded and visible).

R2 object keys are composed in application code as `slug.ext`.

### tag_kinds

- `slug` (`TEXT`, primary key)
- `name` (`TEXT`, not null)
- `system_only` (`INTEGER`, not null, default `0`): marks kinds where user-created tags are not allowed (`1` = system-only kind).

Used to group tags in the UI and filtering model.

### tags

- `slug` (`TEXT`, primary key): canonical `kind/slug` identifier.
- `name` (`TEXT`, not null): display name.
- `kind_slug` (`TEXT`, not null): foreign key to `tag_kinds.slug`, `ON DELETE RESTRICT`.
- `system` (`INTEGER`, not null, default `0`): marks non-user-editable system tags when `1`.

## Join tables

### image_tags

- `image_slug` (`TEXT`, not null): foreign key to `images.slug`, `ON DELETE CASCADE`.
- `tag_slug` (`TEXT`, not null): foreign key to `tags.slug`, `ON DELETE CASCADE`.
- Primary key: (`image_slug`, `tag_slug`).

## Indexes

- `idx_images_added_at` on `images(added_at)`.
- `idx_tags_name` on `tags(name)`.
- `idx_tags_kind` on `tags(kind_slug)`.

## Notes

- Slug format is enforced in application code, not by DB constraints.
- Existing migrations should not be edited retroactively; add new migrations for schema changes.
- Some comments in legacy migration files may reflect historical schema states and are not authoritative for current behavior; this document is authoritative.
